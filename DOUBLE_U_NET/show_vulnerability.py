from utils import load_model_weight
import numpy as np
import matplotlib.pyplot as plt
from predict import parse, read_image, read_mask
from glob import glob
import os
import tensorflow as tf


THRESHOLD = 0.5


def plot_hist(model, in_dataset, out_dataset):
    """
    Plots the histogram (cumulative, in the log space) of the predicted
    probabilities for datasets that is in the training set vs out. The
    histograms are separated by the true labels.

    Parameters:
        `model` - A PyTorch model
        `in_dataset` - A  dataset used for training
        `out_dataset` - A dataset not used for training
    """
    # Obtain the prediction for data points in both data sets
    in_data, in_labels = in_dataset
    out_data, out_labels = out_dataset

    # Data set of samples that were used in training
    in_pred  = get_data_predictions(model, in_data, in_labels) 

    # Data set of samples that were not used in training
    out_pred = get_data_predictions(model, out_data, out_labels)

    # Compute the average negative log() of these predictions, separated by the
    # ground truth labels. An epsilon is added to the prediction for
    # numerical stability
    epsilon = 1e-10
    conf_in_0 = [-np.log(y + epsilon) for t, y in zip(in_labels, in_pred) if y < THRESHOLD]
    print(np.array(conf_in_0).shape)
    return
    conf_in_1 = [-np.log(1 - y + epsilon) for t, y in zip(in_labels, in_pred) if t > THRESHOLD]
    conf_out_0 = [-np.log(y + epsilon) for t, y in zip(out_labels, out_pred) if t < THRESHOLD]
    conf_out_1 = [-np.log(1 - y + epsilon) for t, y in zip(out_labels, out_pred) if t > THRESHOLD]

    # Bins used for the density/histogram
    bins_0 = np.linspace(0,max(max(conf_in_0),max(conf_out_0)),500)
    bins_1 = np.linspace(0,max(max(conf_in_1),max(conf_out_1)),500)

    # Plot the histogram for the predicted probabilities for true label = 0
    plt.subplot(2, 1, 1)
    plt.hist(conf_out_0, bins_0, color='r', label='out', alpha=0.5,cumulative=True, density=True)
    plt.hist(conf_in_0, bins_0, color='b', label='in', alpha=0.5,cumulative=True, density=True)
    plt.legend()
    plt.ylabel('CDF')
    plt.xlabel('-log(Pr(pred=1))')
    plt.title("True label=0")

    # Plot the histogram for the predicted probabilities for true label = 1
    plt.subplot(2, 1, 2)
    plt.hist(conf_out_1, bins_1, color='r', label='out', alpha=0.5,cumulative=True, density=True)
    plt.hist(conf_in_1, bins_1, color='b', label='in', alpha=0.5,cumulative=True, density=True)
    plt.legend()
    plt.title("True label=1")
    plt.ylabel('CDF')
    plt.xlabel('-log(Pr(pred=0))')

    plt.subplots_adjust(hspace=1)
    plt.show()


def get_data(path):
    x = sorted(glob(os.path.join(path, "image", "*.jpg")))
    y = sorted(glob(os.path.join(path, "mask", "*.jpg")))

    return x, y


def get_data_predictions(model, x_data, y_data):
    THRESHOLD = 0.5
    predictions = []
    for i, (x, y) in enumerate(zip(x_data, y_data)):
        x = read_image(x)
        y = read_mask(y)
        _, h, w, _ = x.shape

        y_pred1 = parse(model.predict(x)[0][..., -2])
        y_pred2 = parse(model.predict(x)[0][..., -1])

        predictions.append(y_pred2)
    
    return predictions


model = load_model_weight("files/model.h5")

train_path = "./new_data/train/"
mem_path = "./new_data/memasses/"

train_data, train_labels = get_data(train_path)
mem_data, mem_labels = get_data(mem_path)

train_data, train_labels = train_data[:3], train_labels[:3]
mem_data, mem_labels = mem_data[:3], mem_labels[:3]

# print(np.array(train_data).shape)
# print(np.array(mem_data).shape)

print("GETTING TRAINING DATA PREDICTIONS")
# train_pred = get_data_predictions(model, train_data, train_labels)

print("GETTING MEMORY ASSESSMENT DATA PREDICTIONS")
# mem_pred = get_data_predictions(model, mem_data, mem_labels)

# print(np.array(train_pred).shape)

plot_hist(model, (train_data, train_labels), (mem_data, mem_labels))